class UnionFind {
    int[] Arr;   // parent array
    int[] size;  // size array
    int N;

    // modified initialize function
    void initialize(int N) {
        this.N = N;
        Arr = new int[N];
        size = new int[N];

        for (int i = 0; i < N; i++) {
            Arr[i] = i;   // each element is its own parent
            size[i] = 1;  // initial size = 1
        }
    }

    // modified root function with path compression
    int root(int i) {
        while (Arr[i] != i) {
            Arr[i] = Arr[Arr[i]]; // path compression
            i = Arr[i];
        }
        return i;
    }

    // weighted-union function
    void weighted_union(int A, int B) {
        int root_A = root(A);
        int root_B = root(B);

        if (root_A == root_B) return; // already in same set

        if (size[root_A] < size[root_B]) {
            Arr[root_A] = Arr[root_B];
            size[root_B] += size[root_A];
        } else {
            Arr[root_B] = Arr[root_A];
            size[root_A] += size[root_B];
        }
    }

    // find function
    boolean find(int A, int B) {
        return root(A) == root(B);
    }
    public static void main(String[] args) {
        UnionFind uf = new UnionFind();
        uf.initialize(10);

        uf.weighted_union(1, 2);
        uf.weighted_union(2, 3);
        uf.weighted_union(4, 5);

        System.out.println(uf.find(1, 3)); // true
        System.out.println(uf.find(1, 5)); // false
